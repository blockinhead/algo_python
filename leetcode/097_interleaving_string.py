class Solution:
    def isInterleave(self, s1: str, s2: str, s3: str) -> bool:
        if not s1:
            return s2 == s3
        if not s2:
            return s1 == s3

        d = [[0] * (len(s2) + 1) for _ in range(len(s1) + 1)]

        d[0][0] = True

        # в табличке по вертикали буквы из первого слова, пока второго слова нет
        for i in range(len(s1)):
            if s1[i] == s3[i] and d[i][0] == True:
                d[i + 1][0] = True

        # в табличке по горизонтали пишем буквы из второго слова, пока первого слова нет
        for j in range(len(s2)):
            if s2[j] == s3[j] and d[0][j] == True:
                d[0][j+1] = True

        # for dd in d:
        #     print(dd)

        for i in range(1, len(s1) + 1):
            for j in range(1, len(s2) + 1):
                # s3[3] == 'd' == s1[3] + s2[0]
                # для каждой клетки смотрим две буквы - из первого и второго слова
                # смотрим назад, потому что в нулевом стобце и строке начальные условия
                # когда i=j=1 мы смотрим, на вторую букву с3,
                # может ли первая буква из с1 или с2 быть второй в с3
                # то, что какая-то буква может быть первой мы определили предыдущими двумя циклами
                # ss = s3[i + j - 1]
                # ss1 = s1[i-1]
                # ss2 = s2[j-1]
                # если буква такая же, как в с3, то надо посмотреть,
                # без этой буквы более короткие слова складываются?
                # i перебирает буквы в с1. ответ, всё ли складывается с более коротким с1 лежит на преыдущей строке.
                # j тот же, потому что он про длинну слова с2
                if s1[i-1] == s3[i + j - 1] and d[i-1][j]:
                    d[i][j] = True
                if s2[j-1] == s3[i + j - 1] and d[i][j-1]:
                    d[i][j] = True

        print()
        for dd in d:
            print(dd)

        return d[-1][-1]


print(Solution().isInterleave('aa', 'ab', 'abaa'))
# Solution().isInterleave('abc', 'de', 'adbce')
