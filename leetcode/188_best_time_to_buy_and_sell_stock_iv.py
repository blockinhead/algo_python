from typing import List


class Solution:
    def maxProfit(self, k: int, prices: List[int]) -> int:

        # вместо словаря можно использовать трёхмерный массив, будет быстрее
        cache = {}

        def dive(day, ops, has_stock) -> int:
            if day == len(prices) or ops == 0:
                # если дни кончились или больше нельзя делать транзакций,
                # то больше денег мы не получим
                return 0

            k = (day, ops, has_stock)
            if k in cache:
                return cache[k]

            # сколько денег мы получим при таких исходных - мы не знаем.
            # но мы можем посмотреть, сколько денег мы получим на следующий день
            # если мы ничего делать не будем, то у нас будет столко же денег,
            # сколько будет на следующий день
            res = dive(day + 1, ops, has_stock)

            if has_stock:
                # если у нас есть сток, то можно его продать.
                # сколько будет денег - мы не знаем, но можем посчитать,
                # сколько будет в следующий день,
                # но количество операций уже уменьшится
                res = max(res, dive(day + 1, ops - 1, False) + prices[day])

            if not has_stock:
                # так же, если у нас нет стока, можем его купить.
                # мы не знаем, будет ли это выгоднее, чем ничего не делать,
                # но можем посчитать
                # за операцию считается только пара купить - продать
                res = max(res, dive(day + 1, ops, True) - prices[day])

            cache[k] = res

            return res

        return dive(0, k, False)
        # вместо рекурсии можно использовать стейтмашину,
        # будет линейно по сложности, а не квадратично
