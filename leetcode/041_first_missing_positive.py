class Solution:
    def firstMissingPositive(self, nums: List[int]) -> int:
        l = len(nums)

        mi = float('inf')
        for v in nums:
            if v > 0:
                mi = min(mi, v)
        if mi > 1:
            return 1

        # если наименьшее положительное, которого нет, - не единица, то оно точно меньше, или равно л
        # все числа, которые не попадают в промежуток от 1 до л можно выкинуть. я заменияю их минимальным, хотя можно заменить люым числом в промежутке 1..=л которое есть в массиве.
        for i in range(l):
            if nums[i] < 1 or nums[i] > l:
                nums[i] = mi
        # print(f'{nums}')

        # запишу, на каком месте стоит и-ое число из отфильтрованного массива. признаком наличия числа будет минус на и-ом месте. так как числа в массиве от единицы, а индекс в массиве от нуля - сдвину индекс
        for i in range(l):
            index = abs(nums[i]) - 1
            nums[index] = abs(nums[index]) * -1
        # print(f'{nums}')

        # если данное число положительное, значит элемента с значением и+1 не было в массиве. его и верну
        for i in range(l):
            if nums[i] > 0:
                return i + 1

        # пожоже, в массиве были все числа от 1 до л
        return l + 1
